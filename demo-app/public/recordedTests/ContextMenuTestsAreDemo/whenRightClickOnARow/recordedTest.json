{"slides":[{"screenshot":"Timeline_ganttBody_Timeline_row_0","sourceFile":"ContextMenuTestsAreDemo.tsx","sourceLine":22}],"sourceFiles":{"ContextMenuTestsAreDemo.tsx":"import { Only, Scenario, ScenarioOptions, render, tad } from \"@famiprog-foundation/tests-are-demo\";\nimport { contextMenuTestIds } from \"../../../src/components/ContextMenu/ContextMenu\";\nimport { ContextMenu, addTaskActionIcon, addTaskActionLabel, addTaskNotPossibleAction, deleteActionIcon, deleteActionIconColor, deleteActionLabel, editActionLabel } from \"../stories/contextMenuAndSelection/ContextMenuAndSelection.stories\";\nimport { someHumanResources, someTasks } from \"../stories/sampleData\";\nimport Timeline, { PARENT_ELEMENT, timelineTestids as testids } from \"../../../src/timeline\";\nimport { getPixelAtTime, getTimeAtPixel } from \"../../../src/utils/timeUtils\";\nimport { rightClick } from \"./testUtils\";\n\nconst CLICK_X =30;\nexport class ContextMenuTestsAreDemo {\n\n    async before() {\n        render(<ContextMenu />);\n    }\n\n    @Scenario(\"WHEN I right click on a row, THEN a context menu with one action opens\")\n    @ScenarioOptions({ linkWithNextScenario: true })\n    async whenRightClickOnARow() {\n        // WHEN right click on a row\n        const firstRow = tad.screenCapturing.getByTestId(testids.row + \"_0\");\n        const clickPosition = { clientX: Math.round(firstRow.getBoundingClientRect().x) + CLICK_X, clientY: Math.round(firstRow.getBoundingClientRect().y) + 20 };\n        await tad.showSpotlight({ message: \"I right click on a row\", focusOnLastElementCaptured: true });\n        rightClick(firstRow, clickPosition);\n\n        // THEN CM is opened at the clicked position\n        tad.demoForEndUserHide();\n        const popup = tad.screenCapturing.getByTestId(contextMenuTestIds.popup);\n        await tad.assertWaitable.exists(popup);\n        await this.isPopupPositionedNearPoint(popup.getBoundingClientRect(), { x: clickPosition.clientX, y: clickPosition.clientY });\n        tad.demoForEndUserShow();\n\n        // AND it has an 'Add task' actions\n        let menuEntry = tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_0\");\n        tad.cc(\"The context menu contains an 'Add' action\");\n        await tad.assertWaitable.equal(menuEntry.textContent, addTaskActionLabel + someHumanResources[0].title);\n        tad.demoForEndUserHideNext();\n        await tad.assertWaitable.include(menuEntry.querySelector(\"i\").className, addTaskActionIcon);\n    }\n\n    @Scenario(\"WHEN I click on an action, THEN the action is run (w/ or w/o closing the menu)\")\n    @ScenarioOptions({ linkWithNextScenario: true })\n    async whenClickAnAction() {\n        // WHEN I click on \"Add\"\n        const popup = tad.screenCapturing.getByTestId(contextMenuTestIds.popup);\n        await tad.userEventWaitable.click(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_0\"));\n\n        // THEN a new task is added\n        let newSegment = tad.screenCapturing.getByTestId(testids.item + \"_\" + someTasks.length);\n        await tad.assertWaitable.exists(newSegment);\n\n        tad.demoForEndUserHide();\n        // AND the CM is closed\n        await tad.assertWaitable.notExists(tad.screenCapturing.queryByTestId(contextMenuTestIds.popup));\n\n        // AND the new task is position correctly on x axes\n        // Gantt works with times \"snapped to grid\" so the position for the new task should be snapped to grid \n        const timeline = tad.getObjectViaCheat(Timeline);\n        const firstRow = tad.screenCapturing.getByTestId(testids.row + \"_0\");\n        const ganttLeftOffset = PARENT_ELEMENT(timeline.props.componentId).getBoundingClientRect().left;\n        const clickedX = firstRow.getBoundingClientRect().x + CLICK_X;\n        const clickedXInGantt = clickedX - ganttLeftOffset;\n        const clickedTime = getTimeAtPixel(clickedXInGantt, timeline.getStartDate(), timeline.getEndDate(), timeline.getTimelineWidth(undefined), timeline.getTimelineSnap());\n        const clickedXSnappedToGrid = getPixelAtTime(clickedTime, timeline.getStartDate(), timeline.getEndDate(), timeline.getTimelineWidth(undefined))\n             + ganttLeftOffset;     \n        await tad.assertWaitable.equal(Math.round(newSegment.getBoundingClientRect().x), Math.round(clickedXSnappedToGrid));\n        \n        // AND is correctly added to the clicked row\n        await tad.assertWaitable.equal(newSegment.getBoundingClientRect().y, firstRow.getBoundingClientRect().y);\n        tad.demoForEndUserShow();\n    }\n\n    @Scenario(\"WHEN I right click on a segment, THEN a context menu with 3 actions is shown\")\n    @ScenarioOptions({ linkWithNextScenario: true })\n    async whenRightClickOnASegment() {\n        const segment = tad.screenCapturing.getByTestId(testids.item + \"_0\");\n        const segmentBoundingRect = segment.getBoundingClientRect();\n\n        // WHEN right click on a segment\n        await tad.showSpotlight({ message: \"I right click on a segment\", focusOnLastElementCaptured: true });\n        rightClick(segment, { clientX: segmentBoundingRect.x + segmentBoundingRect.width / 2, clientY: segmentBoundingRect.y + segmentBoundingRect.height / 2 });\n        \n        // THEN the CM opens\n        tad.demoForEndUserHideNext();\n        const popup = tad.screenCapturing.getByTestId(contextMenuTestIds.popup);\n        await tad.assertWaitable.exists(popup);\n\n        // AND it has: 'Add', 'Edit' and 'Delete' actions\n        tad.cc(\"The context menu contains an 'Add' action\");\n        await tad.assertWaitable.equal(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_0\").textContent, addTaskActionLabel + someHumanResources[0].title);\n        \n        tad.cc(\"And an 'Edit' action\");\n        await tad.assertWaitable.equal(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_1\").textContent, editActionLabel);\n        \n        tad.cc(\"And a 'Delete' action\");\n        let menuEntry = tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_2\");\n        await tad.assertWaitable.equal(menuEntry.textContent, deleteActionLabel);\n        tad.cc(\"With a custom red renderer\");\n        tad.demoForEndUserHideNext();\n        await tad.assertWaitable.include(menuEntry.querySelector(\"i\").className, deleteActionIcon);\n        await tad.assertWaitable.include(menuEntry.querySelector(\"i\").className, deleteActionIconColor);\n    }\n\n    @Scenario(\"WHEN I CTRL + right click on another segment, THEN a context menu with 2 actions is shown\")\n    @ScenarioOptions({ linkWithNextScenario: true })\n    async whenCTRLRightClickOnAnotherSegment() {\n        const segment = tad.screenCapturing.getByTestId(testids.item + \"_3\");\n        const segmentBoundingRect = segment.getBoundingClientRect();\n        await tad.showSpotlight({ message: \"WHEN I CTRL + right click another segment\", focusOnLastElementCaptured: true });\n        rightClick(segment, { ctrlKey: true, clientX: segmentBoundingRect.x + segmentBoundingRect.width / 2, clientY: segmentBoundingRect.y + segmentBoundingRect.height / 2 });\n\n        // THEN the CM opens\n        tad.demoForEndUserHideNext();\n        const popup = tad.screenCapturing.getByTestId(contextMenuTestIds.popup);\n        await tad.assertWaitable.exists(popup);\n\n        // AND it has: 'Add' and 'Delete' actions\n        tad.cc(\"The context menu contains an 'Add' action\");\n        await tad.assertWaitable.equal(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_0\").textContent, addTaskActionLabel + someHumanResources[1].title);\n        \n        tad.cc(\"And a 'Delete' action\");\n        await tad.assertWaitable.equal(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_1\").textContent, deleteActionLabel);\n    }\n\n    @Scenario(\"WHEN I click the hamburger button, THEN the context menu is shown besides that button\")\n    async whenClickTheHamburgerButton() {\n        // GIVEN I select one segment\n        await tad.userEventWaitable.click(tad.screenCapturing.getByTestId(testids.item + \"_1\"));\n\n        // WHEN\n        const menuButton = tad.screenCapturing.getByTestId(testids.menuButton);\n        tad.cc(\"Click on the menu button\");\n        await tad.userEventWaitable.click(menuButton);\n\n        // THEN the context menu is opened and positioned near the center of the hamburger button\");\n        tad.demoForEndUserHide();\n        const popup = tad.screenCapturing.getByTestId(contextMenuTestIds.popup);\n        await tad.assertWaitable.exists(popup);\n        const menuButtonCenter = { x: menuButton.getBoundingClientRect().x + menuButton.getBoundingClientRect().width / 2, y: menuButton.getBoundingClientRect().y + menuButton.getBoundingClientRect().height / 2 };\n        await this.isPopupPositionedNearPoint(popup.getBoundingClientRect(), menuButtonCenter);\n        tad.demoForEndUserShow();\n\n        // AND it has: 'Add task: not possible', 'Edit' adn 'Delete' actions\n        tad.cc(\"The context menu contains an 'Add task not possible' action\");\n        await tad.assertWaitable.equal(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_0\").textContent, addTaskNotPossibleAction);\n        tad.cc(\"And an 'Edit' action\");\n        await tad.assertWaitable.equal(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_1\").textContent, editActionLabel);\n        tad.cc(\"And a 'Delete' action\");\n        await tad.assertWaitable.equal(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_2\").textContent, deleteActionLabel);\n\n        // WHEN click 'Edit' (dontCloseContextMenuAfterRunAutomatically = true) THEN the CM doesn't close \n        // We putted this verification at the end of the tests, because else we needed to close the prompt for the next scenarios, and this was not trivial \n        tad.demoForEndUserHide();\n        await tad.userEventWaitable.click(tad.withinCapturing(popup).getByTestId(contextMenuTestIds.menuItem + \"_1\"));\n        await tad.assertWaitable.exists(tad.screenCapturing.getByTestId(contextMenuTestIds.popup));\n        tad.demoForEndUserShow();\n    }\n\n    async isPopupPositionedNearPoint({ x: popupX, y: popupY, width: popupWidth, height: popupHeight }, { x, y }) {\n        const popupEndX = Math.round(popupX + popupWidth);\n        const popupEndY = Math.round(popupY + popupHeight);\n        popupX = Math.floor(popupX);\n        popupY = Math.round(popupY);\n\n        // We didn't understood why it is a difference of some decimals (maximum 1 px) between the expected position and the actual position. \n        // These difference in decimals is not the same every time, is variable regarding the dimension of the window and the dpi of the screen\n        // So the only thing in common is that the actual value is near the expected one at a maximum 1 px distance (below or above)\n        await tad.assertWaitable.include([popupX - 1, popupX, popupX + 1, popupEndX - 1, popupEndX, popupEndX + 1], Math.round(x));\n        // semantic ui popup is displayed 10 px below or 10 px above the mouse position\n        await tad.assertWaitable.include([popupY - 11, popupY - 10, popupY - 9, popupEndY + 9, popupEndY + 10, popupEndY + 11], Math.round(y));\n    }\n}"},"duration":35,"error":"Error: Uncaught TypeError: Cannot read properties of null (reading 'recomputeGridSize') (http://localhost:3000/@fs/home/poweruser/git/react-timeline-10000/src/timeline.js:433)\n\t  at _global.onerror [fn(new Error(err + ' (' + url + ':' + line + ')'));] (http://localhost:3000/node_modules/mocha/browser-entry.js:75:10)"}